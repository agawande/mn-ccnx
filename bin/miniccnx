#!/usr/bin/python

from mininet.topo import Topo
from mininet.net import Mininet
from mininet.log import setLogLevel, output, info
from mininet.cli import CLI
from mininet.node import CPULimitedCCNHost, CCNHost
from mininet.link import TCLink
from mininet.conf_parser import parse_hosts,parse_routers, parse_links
import os.path, time
import optparse
import datetime

def parse_args():
    usage="""Usage: miniccnx [template_file] [ -t | --testbed ]
    If no template_file is given, will try to load template
    from file miniccnx.conf in the current directory.
    If --testbed is used, miniccnx will run the NDN Project Testbed.
    This assumes you are in the testbed directory in the miniccnx installation
    directory.
    """

    testbed = False
    parser = optparse.OptionParser(usage)

    parser.add_option("-t", "--testbed", action="store_true", dest="testbed",
    help="instantiates NDN Testbed")

    (options, arg) = parser.parse_args()

    testbed = options.testbed

    if len(arg) == 0 or len(arg) > 2:
        file = ''
    else:
        file = arg[0]

    return file, testbed


class CCNTopo(Topo):
    def __init__(self, conf_arq, **opts):
        Topo.__init__(self, **opts)

        hosts_conf = parse_hosts(conf_arq)
#       routers_conf = parse_routers(conf_arq)
        links_conf = parse_links(conf_arq)


        self.isTCLink = False
        self.isLimited = False

        for host in hosts_conf:
#	    print host
            if host.cpu != None and self.isLimited != True:
                self.isLimited = True
            self.addHost(host.name, app=host.app, fib=host.uri_tuples,cpu=host.cpu,cores=host.cores,cache=host.cache)

#        for router in routers_conf:
#            if router.cpu != None and self.isLimited != True:
#                self.isLimited = True
#            self.addHost(router.name,fib=router.uri_tuples,cpu=router.cpu,cores=router.cores)

        for link in links_conf:
            if len(link.linkDict) == 0:
                self.addLink(link.h1, link.h2)
            else:
                self.addLink(link.h1, link.h2, **link.linkDict)
                self.isTCLink = True

        info('Parse of ' + conf_arq + ' done.\n')

def execute(template_file='miniccnx.conf', testbed=False):
    "Create a network based on template_file"

    if template_file == '':
        template_file='miniccnx.conf'

    if os.path.exists(template_file) == False:
        info('No template file given and default template file miniccnx.conf not found. Exiting...\n')
        quit()

    topo = CCNTopo(template_file)

    t = datetime.datetime.now()

    if topo.isTCLink == True and topo.isLimited == True:
        net = Mininet(topo,host=CPULimitedCCNHost,link=TCLink)
    elif topo.isTCLink == True and topo.isLimited == False:
        net = Mininet(topo,host=CCNHost,link=TCLink)
    elif topo.isTCLink == False and topo.isLimited == True:
        net = Mininet(topo,host=CPULimitedCCNHost)
    else:
        net = Mininet(topo,host=CCNHost)

    t2 = datetime.datetime.now()

    delta = t2 - t

    info('Setup time: ' + str(delta.seconds) + '\n')

    net.start()

    # Writing neighbors section of NLSR file
    links_conf = parse_links(template_file)
    host_conf = parse_hosts(template_file)    # This is being done twice (The parsing of the file, see CCNTopo)
    host_cost = ""
    neighbor = ""

    hyper = True
    coordinates = {}
    for host in host_conf:
	if host.radius == None or host.angle == None:
	    hyper = False
	else:
	    coordinates[host.name] = str(host.radius) + " " + str(host.angle)

    if hyper:
	for host in net.hosts:
	    host.cmd("sudo sed -i \'89s|.*|  state on|\' nlsr.conf")
	    host.cmd("sudo sed -i \'94s|.*|  radius  "+coordinates[str(host)].split()[0]+"|\' nlsr.conf")
	    host.cmd("sudo sed -i \'95s|.*|  angle  "+coordinates[str(host)].split()[1]+"|\' nlsr.conf")
	

    for link in links_conf:
	host_cost = link.linkDict['cost']
	for host in net.hosts:
	    if str(host) == link.h1:
		for iface in host.intfList():
		    l1 = iface.link
		    if(str(l1.intf2.node) == link.h2):
			ip =  ipNode(net, link.h2, l1.intf2)
		    if(str(l1.intf1.node) == link.h2):
			ip =  ipNode(net, link.h2, l1.intf1)

		neighbor += "neighbor\\n{\\nname /ndn/edu/memphis/%C1.Router/cs/"+link.h2+"\\nface-uri udp://"+str(ip)+"\\nlink-cost "+str(host_cost) + "\\n}\\n"
	        host.cmd("sudo sed -i \'70i\'\""+neighbor+"\" nlsr.conf")
                neighbor=""
	    elif str(host) == link.h2:
		for iface in host.intfList():
		    l2 = iface.link
		    if(str(l2.intf1.node) == link.h1):
			ip2 = ipNode(net, link.h1, l2.intf1)
		    if(str(l2.intf2.node) == link.h1):
			ip2 = ipNode(net, link.h1, l2.intf2)
		neighbor += "neighbor\\n{\\nname /ndn/edu/memphis/%C1.Router/cs/"+link.h1+"\\nface-uri udp://"+str(ip2)+"\\nlink-cost "+str(host_cost) + "\\n}\\n"
		host.cmd("sudo sed -i \'70i\'\""+neighbor+"\" nlsr.conf")
                neighbor=""

    for host in net.hosts:
	print(host.cmd("nlsr -d"))

    if testbed == True:
        info('Starting OSPFN ...\n')
        for host in net.hosts:
            host.cmd("cd {0}".format(host.name))
            host.cmd("./routing.sh {0}".format(host.name))

        time.sleep(60)

        for host in net.hosts:
            host.cmd("./ospfn-start.sh {0}".format(host.name))

        info('OSPFN configuration completed!\n')

    for host in net.hosts:
        if 'app' in host.params:
            if host.params['app'] != '_':
                host.cmd(host.params['app'])

    CLI(net)
    net.stop()

def ipNode(net, neighbor, intf):
	for host in net.hosts:
	    if(str(host) == neighbor):
		return host.IP(str(intf))


if __name__ == '__main__':

    template, testbed = parse_args()
    setLogLevel('info')
    execute(template, testbed)
