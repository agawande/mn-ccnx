#!/usr/bin/python

from mininet.topo import Topo
from mininet.net import Mininet
from mininet.log import setLogLevel, output, info
from mininet.cli import CLI
from mininet.node import CPULimitedCCNHost, CCNHost
from mininet.link import TCLink
from mininet.conf_parser import parse_hosts,parse_routers, parse_links
import os.path, time
import optparse
import datetime

def parse_args():
    usage="""Usage: miniccnx [template_file] [ -t | --testbed ]
    If no template_file is given, will try to load template
    from file miniccnx.conf in the current directory.
    If --testbed is used, miniccnx will run the NDN Project Testbed.
    This assumes you are in the testbed directory in the miniccnx installation
    directory.
    """

    testbed = False
    parser = optparse.OptionParser(usage)

    parser.add_option("-t", "--testbed", action="store_true", dest="testbed",
    help="instantiates NDN Testbed")

    (options, arg) = parser.parse_args()

    testbed = options.testbed

    if len(arg) == 0 or len(arg) > 2:
        file = ''
    else:
        file = arg[0]

    return file, testbed


class CCNTopo(Topo):
    def __init__(self, conf_arq, **opts):
        Topo.__init__(self, **opts)

        hosts_conf = parse_hosts(conf_arq)
#       routers_conf = parse_routers(conf_arq)
        links_conf = parse_links(conf_arq)


        self.isTCLink = False
        self.isLimited = False

        for host in hosts_conf:
#	    print host
            if host.cpu != None and self.isLimited != True:
                self.isLimited = True
            self.addHost(host.name, app=host.app, fib=host.uri_tuples,cpu=host.cpu,cores=host.cores,cache=host.cache)

#        for router in routers_conf:
#            if router.cpu != None and self.isLimited != True:
#                self.isLimited = True
#            self.addHost(router.name,fib=router.uri_tuples,cpu=router.cpu,cores=router.cores)

        for link in links_conf:
            if len(link.linkDict) == 0:
                self.addLink(link.h1, link.h2)
            else:
                self.addLink(link.h1, link.h2, **link.linkDict)
                self.isTCLink = True

        info('Parse of ' + conf_arq + ' done.\n')

def execute(template_file='miniccnx.conf', testbed=False):
    "Create a network based on template_file"

    if template_file == '':
        template_file='miniccnx.conf'

    if os.path.exists(template_file) == False:
        info('No template file given and default template file miniccnx.conf not found. Exiting...\n')
        quit()

    topo = CCNTopo(template_file)

    t = datetime.datetime.now()

    if topo.isTCLink == True and topo.isLimited == True:
        net = Mininet(topo,host=CPULimitedCCNHost,link=TCLink)
    elif topo.isTCLink == True and topo.isLimited == False:
        net = Mininet(topo,host=CCNHost,link=TCLink)
    elif topo.isTCLink == False and topo.isLimited == True:
        net = Mininet(topo,host=CPULimitedCCNHost)
    else:
        net = Mininet(topo,host=CCNHost)

    t2 = datetime.datetime.now()

    delta = t2 - t

    info('Setup time: ' + str(delta.seconds) + '\n')

    net.start()

    # Writing neighbors section of NLSR file
    links_conf = parse_links(template_file)
    host_ip = ""
    host_cost = ""
    neighbor = ""

    #Saving IPs in a dictionary for later use
    ip_node = {}
    for host in net.hosts:
#	print("Host: " + str(host))
        ip_node[str(host)] = host.IP()
	#ip_node[str(host)] = host.IP(str(host)"-eth1")
	#interface = host.intfNames();
#	for iface in host.intfList():
#	    print("Interface: "+str(iface))
#	    link = iface.link
#	    if link:
#		print("Link: "+str(link.intf2) + " host1: " +str(link.intf1.node) + " host2: " + str(link.intf2.node))
#	print("\n")
	#print("IP of " + str(host) +" is "+ip_node[str(host)])

    for link in links_conf:
	#print(str(link.h1)+" "+str(link.h2)+" " + str(link.linkDict))
	host_cost = link.linkDict['cost']
	for host in net.hosts:
	    if str(host) == link.h1:
		if(host.intfList()!=1):
		    ip = getIP(net, host, link.h2)
		else:
		    ip = ip_node[link.h2]		    
		#print(host.intf()
		#print("host: "+str(host) + " to " +link.h1 + ": "+ip_node[link.h2])
		neighbor += "neighbor\\n{\\nname /ndn/edu/memphis/%C1.Router/cs/"+link.h2+"\\nface-uri udp://"+str(ip)+"\\nlink-cost "+str(host_cost) + "\\n}\\n"
        	#print(host.cmd("cd /home/ashu/Desktop && sudo ./setNeighbor \""+neighbor+"\""))
	        host.cmd("sudo sed -i \'70i\'\""+neighbor+"\" nlsr.conf")
                neighbor=""
	    elif str(host) == link.h2:
		if(host.intfList()!=1):
		    ip = getIP(net, host, link.h1)
		else:
		    ip = ip_node[link.h1]	
		neighbor += "neighbor\\n{\\nname /ndn/edu/memphis/%C1.Router/cs/"+link.h1+"\\nface-uri udp://"+str(ip)+"\\nlink-cost "+str(host_cost) + "\\n}\\n"
		host.cmd("sudo sed -i \'70i\'\""+neighbor+"\" nlsr.conf")
                neighbor=""

    for host in net.hosts:
	print(host.cmd("echo $HOME"))
	print(host.cmd("nlsr -d"))

    #ip_node = open("miniccnx.conf", "wb")
    #for host in net.hosts:
	
	#ip_node.write(host.name)
	#ip_node.write(" ")
	#ip_node.write(host.IP())
	#ip_node.write("\n")
    #ip_node.close()    

    if testbed == True:
        info('Starting OSPFN ...\n')
        for host in net.hosts:
            host.cmd("cd {0}".format(host.name))
            host.cmd("./routing.sh {0}".format(host.name))

        time.sleep(60)

        for host in net.hosts:
            host.cmd("./ospfn-start.sh {0}".format(host.name))

        info('OSPFN configuration completed!\n')

    for host in net.hosts:
        if 'app' in host.params:
            if host.params['app'] != '_':
                host.cmd(host.params['app'])

    CLI(net)
    net.stop()

def getIP(net, node, neighbor):
	print(str(node) + " connected to " + neighbor)
	for host in net.hosts:
	    if str(host) == str(node):
		#print("host: "+str(host))
		for iface in host.intfList():
		    link = iface.link
		    #print("Link: "+str(link))
		    #print(str(link.intf2.node) +"("+link.intf2 +"),  neighbor: " + neighbor)
		    if(str(link.intf2.node) == neighbor):
			return ipNode(net, neighbor, link.intf2)
		    elif(str(link.intf1.node) == neighbor):
			return ipNode(net, neighbor, link.intf1)

def ipNode(net, neighbor, intf):
	print("Neighbor: "+neighbor + " Interface: " + str(intf))
	for host in net.hosts:
	    if(str(host) == neighbor):
		#print("Neighbor: "+neighbor)
		return host.IP(str(intf))


if __name__ == '__main__':

    template, testbed = parse_args()
    setLogLevel('info')
    execute(template, testbed)
