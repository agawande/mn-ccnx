#!/usr/bin/python

from mininet.topo import Topo
from mininet.net import Mininet
from mininet.log import setLogLevel, output, info
from mininet.cli import CLI
from mininet.node import CPULimitedCCNHost, CCNHost
from mininet.link import TCLink
from mininet.conf_parser import parse_hosts,parse_routers, parse_links
import os.path, time
import optparse
import datetime

def parse_args():
    usage="""Usage: miniccnx [template_file] [ -t | --testbed ]
    If no template_file is given, will try to load template
    from file miniccnx.conf in the current directory.
    If --testbed is used, miniccnx will run the NDN Project Testbed.
    This assumes you are in the testbed directory in the miniccnx installation
    directory.
    """

    testbed = False
    pingall = False
    hr = False
    failure = False

    parser = optparse.OptionParser(usage)

    parser.add_option("-t", "--testbed", action="store_true", dest="testbed",
    help="instantiates NDN Testbed")

    parser.add_option("--pingall", action="store", dest="pingall", type="int",
    help="Sequentiall pings all the other nodes from each node")

    parser.add_option("--ctime", action="store", dest="ctime", type="int",
    help="Specify convergence time for the topology (Default 60 seconds)")

    parser.add_option("--hr", action="store_true", dest="hr",
    help="--hr is used to turn on hyperbolic routing")

    parser.add_option("--faces", action="store", dest="faces", type="int",
    help="Specify number of faces 0-60")

    parser.add_option("--failure", action="store_true", dest="failure",
    help="Run failure experiment, specify the number of pings using pingall")

    (options, arg) = parser.parse_args()

    testbed = options.testbed
    pingall = options.pingall
    ctime = options.ctime
    hr = options.hr
    faces = options.faces
    failure = options.failure
    
    if ctime is None:
	ctime = 60

    if faces is None:
	faces = 3

    if len(arg) == 0 or len(arg) > 2:
        file = ''
    else:
        file = arg[0]

    return file, testbed, pingall, ctime, hr, faces, failure

class CCNTopo(Topo):
    def __init__(self, conf_arq, **opts):
        Topo.__init__(self, **opts)

	global hosts_conf
	global links_conf
        hosts_conf = parse_hosts(conf_arq)
#       routers_conf = parse_routers(conf_arq)
        links_conf = parse_links(conf_arq)

        self.isTCLink = False
        self.isLimited = False

        for host in hosts_conf:
#	    print host
            if host.cpu != None and self.isLimited != True:
                self.isLimited = True
            self.addHost(host.name, app=host.app, fib=host.uri_tuples,cpu=host.cpu,cores=host.cores,cache=host.cache)

#        for router in routers_conf:
#            if router.cpu != None and self.isLimited != True:
#                self.isLimited = True
#            self.addHost(router.name,fib=router.uri_tuples,cpu=router.cpu,cores=router.cores)

        for link in links_conf:
            if len(link.linkDict) == 0:
                self.addLink(link.h1, link.h2)
            else:
                self.addLink(link.h1, link.h2, **link.linkDict)
                self.isTCLink = True

        info('Parse of ' + conf_arq + ' done.\n')

def execute(template_file='miniccnx.conf', testbed=False, pingall=None, ctime=None, hr=False, faces=None, failure=False):
    "Create a network based on template_file"

    if template_file == '':
        template_file='miniccnx.conf'

    if os.path.exists(template_file) == False:
        info('No template file given and default template file miniccnx.conf not found. Exiting...\n')
        quit()

    topo = CCNTopo(template_file)

    t = datetime.datetime.now()

    if topo.isTCLink == True and topo.isLimited == True:
        net = Mininet(topo,host=CPULimitedCCNHost,link=TCLink)
    elif topo.isTCLink == True and topo.isLimited == False:
        net = Mininet(topo,host=CCNHost,link=TCLink)
    elif topo.isTCLink == False and topo.isLimited == True:
        net = Mininet(topo,host=CPULimitedCCNHost)
    else:
        net = Mininet(topo,host=CCNHost)

    t2 = datetime.datetime.now()

    delta = t2 - t

    info('Setup time: ' + str(delta.seconds) + '\n')

    net.start()

    # Writing neighbors section of NLSR file
    #links_conf = parse_links(template_file)
    #host_conf = parse_hosts(template_file)    # This is being done twice (The parsing of the file, see CCNTopo)
    host_cost = ""
    neighbor = ""

    hyper = True
    coordinates = {}
    nodes = ""    # Used later to check prefix name in checkFIB
    # If hyperbolic coordinates defines for all the nodes then start hyperbolic routing
    for host in hosts_conf:
	nodes += str(host.name)+","
	if host.radius == None or host.angle == None:
	    hyper = False
	else:
	    coordinates[host.name] = str(host.radius) + " " + str(host.angle)
    
    nodes = nodes[0:-1]
    #print nodes

    # Number of faces allowed, default is 3
    for host in net.hosts:
	host.cmd("sudo sed -i \'106s|.*|  max-faces-per-prefix "+str(faces)+"|\' nlsr.conf")

    if hr and hyper:
	for host in net.hosts:
	    host.cmd("sudo sed -i \'89s|.*|  state on|\' nlsr.conf")
	    host.cmd("sudo sed -i \'94s|.*|  radius  "+coordinates[str(host)].split()[0]+"|\' nlsr.conf")
	    host.cmd("sudo sed -i \'95s|.*|  angle  "+coordinates[str(host)].split()[1]+"|\' nlsr.conf")
	
    for link in links_conf:
	host_cost = link.linkDict['cost']
	for host in net.hosts:
	    if str(host) == link.h1:
		for iface in host.intfList():
		    l1 = iface.link
		    if(str(l1.intf2.node) == link.h2):
			ip =  ipNode(net, link.h2, l1.intf2)
		    if(str(l1.intf1.node) == link.h2):
			ip =  ipNode(net, link.h2, l1.intf1)

		neighbor += "neighbor\\n{\\nname /ndn/edu/%C1.Router/cs/"+link.h2+"\\nface-uri udp://"+str(ip)+"\\nlink-cost "+str(host_cost) + "\\n}\\n"
		host.cmd("sudo sed -i \'70i\'\""+neighbor+"\" nlsr.conf")
	        neighbor=""
	    elif str(host) == link.h2:
		for iface in host.intfList():
		    l2 = iface.link
		    if(str(l2.intf1.node) == link.h1):
			ip2 = ipNode(net, link.h1, l2.intf1)
		    if(str(l2.intf2.node) == link.h1):
			ip2 = ipNode(net, link.h1, l2.intf2)
		neighbor += "neighbor\\n{\\nname /ndn/edu/%C1.Router/cs/"+link.h1+"\\nface-uri udp://"+str(ip2)+"\\nlink-cost "+str(host_cost) + "\\n}\\n"
		host.cmd("sudo sed -i \'70i\'\""+neighbor+"\" nlsr.conf")
	        neighbor=""

    for host in net.hosts:
	host.cmd("nlsr -d")
	host.cmd("./checkFIB "+nodes+" "+str(host) +" "+str(ctime)+" &")
	#host.cmd("nfdc set-strategy /ndn/edu ndn:/localhost/nfd/strategy/ncc &")
	host.cmd("ndnpingserver /ndn/edu/"+str(host)+" &")
	#host.cmd("ndndump > dump."+str(host)+" &")
	#host.cmd("./nfdstatus > status."+str(host) +" &")

    if pingall is not None:
        time.sleep(ctime)       # waiting the same time as the convergence time before starting ping
        for host in net.hosts:
            host.cmd("mkdir ping-data")
	    for each in net.hosts:
	        if(str(host)!=str(each)):    #if failure: if(str(host)!="csu"):
		    host.cmd("ndnping -c "+ str(pingall) + " /ndn/edu/"+str(each)+" > ping-data/"+str(each)+".txt &")   #if we add "&" here we make can make parallel ping
		    time.sleep(.2)
		    #else:
			#host.cmd("ndnping -c "+ str(pingall) + " /ndn/edu/"+str(each)+" > ping-data/"+str(each)+".txt")

	if failure:
	    time.sleep(60)   # modification for faliure experiment, sleep for 1 minute (At 4th minute bring down csu)
	    for host in net.hosts:
	        if str(host) == "csu":
		    host.cmd("sudo kill `ps aux | grep nfd| grep sudo | grep csu | awk '/csu.conf/ { print $2}'`")
		    break

	    time.sleep(120) # At 6th minute bring up csu
	    for host in net.hosts:
                if str(host) == "csu":
		    host.cmd("sudo nfd --config csu.conf &")
		    time.sleep(1)
		    host.cmd("sudo nrd --config csu.conf &")
		    time.sleep(1)
		    host.cmd("nlsr -d")
	   	    host.cmd("nfdc set-strategy /ndn/edu ndn:/localhost/nfd/strategy/ncc &")
		    #host.cmd("nfdc set-strategy /ndn/edu/"+str(host)+" ndn:/localhost/nfd/strategy/ncc > strategy &")
		    host.cmd("ndnpingserver /ndn/edu/"+str(host)+" &")
	 	    break

	    time.sleep(60)
	

    #if testbed == True:
     #   info('Starting OSPFN ...\n')
      #  for host in net.hosts:
       #     host.cmd("cd {0}".format(host.name))
       #     host.cmd("./routing.sh {0}".format(host.name))

       # time.sleep(60)

       # for host in net.hosts:
       #     host.cmd("./ospfn-start.sh {0}".format(host.name))

       # info('OSPFN configuration completed!\n')

    for host in net.hosts:
        if 'app' in host.params:
            if host.params['app'] != '_':
                host.cmd(host.params['app'])

    #print(net.configLinkStatus("csu", "caida", "down"))
    #print(net.configLinkStatus("h1", "s1", "down"))

    CLI(net)
    net.stop()

def ipNode(net, neighbor, intf):
	for host in net.hosts:
	    if(str(host) == neighbor):
		return host.IP(str(intf))


if __name__ == '__main__':
    hosts_conf = []
    links_conf = []
    template, testbed, pingall, ctime, hr, faces, failure = parse_args()
    setLogLevel('info')
    execute(template, testbed, pingall, ctime, hr, faces, failure)
